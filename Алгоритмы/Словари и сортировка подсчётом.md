## Что такое сортировка подсчетом
- Пусть необходимо отсортировать массив из N целых чисел, каждое от 0 до K
- Обычная сортировка, в лучшем случае, займет O(Nlog(N))
- В нашем же случае мы будем считать количество вхождений каждого числа, а затем выводить каждое число столько раз, сколько оно встречалось. Это займет O(N + K) и O(K) дополнительной памяти
- Интервал значений можно сдвинуть, чтобы он был не от 0 до K, а до минимального до максимального
> Сейчас я напишу пример как я это понял, а далее приведу пример из лекции

```
const countSorting = (arr) => {

    const voc = {};

    const resArr = [];

  

    for (let i = 0; i < arr.length; i++) {

        if (voc[arr[i]]) {

            voc[arr[i]]++;

        } else {

            voc[arr[i]] = 1;

        }

    }

  
  

    return Object.entries(voc).flatMap(([key, value]) => Array.from({ length: value }, () => Number(key)));

  

}

  

const arr = [10, 4, 1, 1, 12, 3, 0, 8, 3, 2, 9, 5, 1, 6, 7]

console.log(countSorting(arr)) // [0, 1, 1, 1, 2, 3, 3, 4, 5, 6, 7, 8, 9, 10, 12]
```

> Решение, которое было представлено:

```
const countSorting = (arr) => {

   const minVal = Math.min(...arr)

   const maxVal = Math.max(...arr)

   const k = maxVal - minVal + 1 // Считаем сколько получится элементов в новом массиве

   const count  = new Array(k).fill(0) // Заполняем массив нулями

  

   for (let i = 0; i < arr.length; i++) {

      count[arr[i] - minVal] += 1; // Считаем сколько раз встречается элемент

   }

   console.log(count)

   let newPos = 0;

   for (let i = 0; i < k; i++) { // Проходимаем по новому массиву

    for (let j = 0; j < count[i]; j++) { // Проходим по количеству встречаемых элементов

        arr[newPos++] = i + minVal;

    }

   }

  
  

   return arr

  

}

  

// Распишем данный алгоритм по шагам на примере данного массива [10, 4, 1, 1, 12, 3, 0, 8, 3, 2, 9, 5, 1, 6, 7]

// 1) Находим максимум и минимум в массиве, максимум = 12, минимум = 0

// 2) Находим разницу максимума и минимума 12 - 0 = 12

// 3) Создаем новый массив с длиной 12, заполняем его нулями

// 4) Итерируемся по исходному массиву и считаем сколько раз встречается элемент

//     count[arr[i] - minVal] += 1; // Считаем сколько раз встречается элемент

//     На примере первого элемента count[10 - 0] += 1 = 1

//     Второй элемент count[4 - 0] += 1 = 1

//     Когда нам встречается повтороение, счетчик увеличивается на единицу

//     для третьего элемента: count[1 - 0] += 1 = 1

//     для четвертого элемента count[1 - 0] += 1 = 2

// 5) Заводом число newPos = 0

// 6) Итерируемся по новому массиву при помощи k

// 7) Итерируемся по числу встречаемых элементов, то есть когда на какому то элементе не 1, а 3, то под него выделяется 3 места в массиве, если там 0, то итерации нет, значит и заполнения нетarr[newPos++] = i + minVal;

  

// 8) Возвращаем исходный мутированный массив

const arr = [10, 4, 1, 1, 12, 3, 0, 8, 3, 2, 9, 5, 1, 6, 7]

console.log(countSorting(arr)) // [0, 1, 1, 1, 2, 3, 3, 4, 5, 6, 7, 8, 9, 10, 12]
```

Задачи:
> Дано два числа X и Y без ведущих нулей. Необходимо проверить, можно ли получить первое число из второго перестановкой цифр

```
const findDigitsCount = (num) => {

    const digitsCount = Array(String(num).length).fill(0);

    while(num > 0) {

        const digit = num % 10;

        digitsCount[digit]++;

        num = Math.floor(num / 10);

    }

    return digitsCount;

}

  

const firstTask = (x, y) => {

    const arrXCount = findDigitsCount(x)

    const arrYCount = findDigitsCount(y)

    if (arrXCount.length !== arrYCount.length) {

        return false

    }

    for (let i = 0; i < arrXCount.length; i++) {

        if (arrXCount[i] !== arrYCount[i]) {

            return false

        }

    }

  

    return true

  

}

console.log(firstTask(1123, 2113)) // true

console.log(firstTask(1123, 2123)) // false
```

## Словари
- Словарь как множество, но к нему приписано значение
- Искать по значению в словаре нельзя
- Константа в сложности словарей заметно больше, чем у массивов, поэтому где можно - лучше использовать сортировку подсчётом
- Сортировку подсчётом неразумно использовать, если данные разреженные