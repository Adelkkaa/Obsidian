## 1. Сложность 
- Сложность алгоритма - это порядок количества действий, которые выполняет алгоритм
- Например, в программе два цикла, каждый из которых итерируется N раз, значит сложность O(N^2)

Также стоит помнить, что существует несколько трактовок сложности, также существует пространственная сложность, которая отвечает за количество используемой памяти

Задача:
Описание: Дана строка в кодировке utf-8, нужно найти символ, который встречается в этой строке чаще всего

По моему мнению самое лучшее решение для этой задачи - это создание словаря
```
const str = 'Helloooooo'
const someFn = (str) => {
    let max = 0;
    let result;
    
const vocabulary = str.split('').reduce((acc, cur) => {
        if (acc[cur]) {
            acc[cur] += 1
        } else {
            acc[cur] = 1
        }
        return acc
    }, {})
for (const val in vocabulary ) {
    if (vocabulary[val] > max) {
        max = vocabulary[val];
        result = val
    }
}
return result
}

console.log(someFn(str))
```
В данном случае мы итерируемся по двум циклам
1. Сложность первого цикла - N, потому что итерируемся по всем элементам строки
2. Сложность второго цикла - K, потому что итерируемся по какой то части элементов строки
3. Итоговая сложность O(N + K), если отбросить константы, то сложность O(N)
Используем + потому что циклы не вложены, а идут друг за другом, если была бы итерация цикла внутри другого цикла - сложность была бы O(N^2)

## 2. Линейный поиск 
Линейный поиск - это способ поиска, когда перебираются ==все элементы==
Сложность линейного поиска - линейная O(N)
Обычно ищут подходящий элемент или наиболее подходящий элемент

- Задача первого вхождения в строку

```// Нахождение первого вхождения

// Решение для наглядности

const findFirst = (str, findStr) => {
    const arr = str.split("");
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === findStr) {
            return i
        }
    }
    return -1
}

console.log(findFirst('hekki', 'k')) // 2
```

Данное решение весьма топорное, поэтому для повышения читаемости, я бы сделал вот так:

```
const findFirst = (str, findStr) => {
    return str.indexOf(findStr)
}

console.log(findFirst('hekki', 'k')) // 2
```

- Задача нахождения локального максимума
Конечно же я бы просто решил задачу вот так
```
// Нахождение локального максимума

const findMax = (arr) => {
    return Math.max(...arr)
}

console.log(findMax([1, 3, 4, 10, 12, 4])) // 12

```

ИЛИ вот так
```
// Нахождение локального максимума

const findMax = (arr) => {
    return [...arr].sort((x, y) => x - y)[arr.length - 1]
}

console.log(findMax([1, 3, 4, 10, 12, 4])) // 12


```

Но для наглядности приведу пример
```
// Нахождение локального максимума

const findMax = (arr) => {
    let index = 0;
    for (let i = 0; i < arr.length; i++) {
        if (arr[index] < arr[i]) {
            index = i
        }
    }
    return arr[index]
}

console.log(findMax([1, 3, 4, 10, 12, 4])) // 12
```

Если вчитаться в решение, то можно обнаружить, что я взял не сам первый элемент, а лишь его индекс, все потому что сложность присваивания разных структур данных имеет разную сложность, поэтому я присваиваю индексы, сложность которых O(1)


- Дана последовательность чисел длиной N (N > 1). Найти максимальное число в последовательности и второе по величине число (такое, которое будет максимальным, если вычеркнуть из последовательности одно максимальное число)

Ну конечно же я бы тут просто отсортировал последовательность и вывел два последних числа
```
const findMax = (arr) => {
    const newArr = [...arr].sort((x, y) => x - y)
    return [newArr[arr.length - 1], newArr[arr.length - 2]]
}

console.log(findMax([1, 3, 4, 10, 12, 4])) // [12, 10]
```
Но нужно адекватное решение

```
// Нахождение локального максимума

const findMax = (arr) => {
   let firstMax = Math.max(arr[0], arr[1]);
   let secondMax = Math.min(arr[0], arr[1]);
   
   for (let i = 0; i < arr.length; i++) {
       if (arr[i] > firstMax) {
           secondMax = firstMax;
           firstMax = arr[i]
       } 
   }
   return [firstMax, secondMax]
}

console.log(findMax([1, 3, 4, 10, 12, 4])) // [12, 10]
```

> [!Комментарий к задаче]
> Расписываем порядок: 
> Для того чтобы решить эту задачу без сортировки необходимо завести две переменные, первая обязательно наибольшее число из первых двух элементов последовательности, второе наименьшее, далее проходимся по последовательности и при нахождении элемента большего чем максимальное число - присваиваем второму максимуму первый максимум, а первому максимуму новый элемент

- Дана последовательность чисел длиной N. Найти минимальное четное число в последовательности или вывести -1, если такого числа не существует.
```
// Нахождение четного минимума

const findMin = (arr) => {
   let min = -1;
   
   for(let i = 0; i < arr.length; i++) {
       if (arr[i] % 2 === 0 && (arr[i] < min || min === -1)) {
           min = arr[i]
       }
   }
   return min
}

console.log(findMin([1, 3, 3, 10, 12, 3])) // 10
```


> [!Комментарий] Комментарий
> Хорошим тоном при решении таких задач не заводить проверку на min === -1, а завести boolean переменную, которая будет сигнализировать о том, что число ещё ни разу не присваивалось

```
// Нахождение четного минимума

const findMin = (arr) => {
   let min = -1;
   let flag = false
   
   for(let i = 0; i < arr.length; i++) {
       if (arr[i] % 2 === 0 && (arr[i] < min || !flag)) {
           flag = true
           min = arr[i]
       }
   }
   return min
}

console.log(findMin([1, 3, 3, 10, 12, 3])) // 10
```

Алгоритмы, требующие двух проходов
- Дана последовательность слов, вывести все самые короткие слова через пробел
```

const findMinStr = (str) => {
    const arr = str.split(" ");
   let minLength = arr[0].length;
   let res = []
   for (let i = 0; i < arr.length; i++) {
       if (arr[i].length < minLength) {
           minLength = arr[i].length
       }
   }
   for (let i = 0; i < arr.length; i++) {
        if (arr[i].length === minLength) {
          res.push(arr[i])
       }
   }
   return res.join(' ')
}

console.log(findMinStr('hello my dear bu')) // my bu

```


> [!NOTE] Комментарий
> Конечно, можно было бы решить эту задачу проходом по одному циклу, но сложность алгоритма была бы выше, потому что пришлось бы работать с памятью, но давайте покажу как это можно было бы сделать одним проходом

```

const findMinStr = (str) => {
    const arr = str.split(' ');
    let minLength = arr[0].length
    let res = [arr[0]];
    
    for (let i = 0; i < arr.length; i++) {
        if (arr[i].length < minLength) {
            res = []
            minLength = arr[i].length;
        }
        if (arr[i].length === minLength) {
             res.push(arr[i])
        }
    }
    return res.join(' ');
}

console.log(findMinStr('hello my dear bu')) // my bu


```
